#!/usr/bin/env bash
set -euo pipefail

CURRENT_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

source "$CURRENT_PATH/../lib/utils.sh"

export LOG_NAMESPACE="[SCRIPTS][ALLOWLIST]"
source_as "$CURRENT_PATH/../lib/logger.sh" "LOGGER"

init_allowlist() {
  LOGGER info "ALLOWLIST: Setup DNS-based filtering with ipset"

  if [[ -f "$CURRENT_PATH/../.env" ]]; then
    source "$CURRENT_PATH/../.env"
  else
    LOGGER error "Missing .env file â€“ cannot proceed"
    exit 1
  fi

  PROJECT_ROOT="$CURRENT_PATH/.."
  WHITELIST_FILE="$PROJECT_ROOT/config/whitelist.txt"
  ALLOW_ALL_IPS_FILE="$PROJECT_ROOT/config/allow_all_ips.txt"
  DNSMASQ_CONF="/etc/dnsmasq.d/whitelist.conf"
  IPSET_RESTORE_SERVICE="/etc/systemd/system/ipset-restore.service"

  LOGGER step "Cleaning existing ipsets and iptables rules"

  sudo iptables -D FORWARD -m set --match-set allow_all src -j ACCEPT 2>/dev/null || true
  sudo iptables -D FORWARD -m set --match-set whitelist dst -j ACCEPT 2>/dev/null || true
  sudo iptables -D FORWARD -j REJECT 2>/dev/null || true

  if sudo ipset list allow_all &>/dev/null; then
    sudo ipset flush allow_all || true
    sudo ipset destroy allow_all || true
  fi

  if sudo ipset list whitelist &>/dev/null; then
    sudo ipset flush whitelist || true
    sudo ipset destroy whitelist || true
  fi

  LOGGER step "Creating ipsets"
  sudo ipset create whitelist hash:ip
  sudo ipset create allow_all hash:ip

  LOGGER step "Generating dnsmasq whitelist config"
  echo "# Generated by wifi-ap allowlist" | sudo tee "$DNSMASQ_CONF" > /dev/null
  while IFS= read -r domain; do
    [[ -z "$domain" || "$domain" =~ ^# ]] && continue
    echo "ipset=/$domain/whitelist" | sudo tee -a "$DNSMASQ_CONF" > /dev/null
  done < "$WHITELIST_FILE"

  # ðŸ”’ Isoler dnsmasq sur l'interface AP pour Ã©viter le conflit avec systemd-resolved
  WIFI_AP_CONF="/etc/dnsmasq.d/wifi-ap.conf"
  # Essaie de rÃ©cupÃ©rer l'IP de l'AP (fallback 10.0.0.1 si non dispo)
  AP_IP="$(ip -4 addr show dev "$wireless_id" | awk '/inet /{print $2}' | cut -d/ -f1 || true)"
  [[ -z "$AP_IP" ]] && AP_IP="10.0.0.1"

  LOGGER step "Writing dnsmasq interface binding (listen only on $wireless_id:$AP_IP)"
  sudo tee "$WIFI_AP_CONF" > /dev/null <<EOF
# Bind only to the AP interface to avoid port 53 conflicts with systemd-resolved
interface=$wireless_id
bind-dynamic
listen-address=$AP_IP

# Don't use system resolv.conf; forward upstream explicitly
no-resolv
server=1.1.1.1
server=1.0.0.1

# DHCP for AP clients (adjust range if needed)
dhcp-range=$AP_IP,static,255.255.255.0,12h
dhcp-option=option:router,$AP_IP
dhcp-option=option:dns-server,$AP_IP
EOF

  # VÃ©rifier si le port 53 est pris par systemd-resolved pour info
  if sudo ss -ltnp '( sport = :53 )' 2>/dev/null | grep -q systemd-resolved; then
    LOGGER warn "Port 53 in use by systemd-resolved â€” dnsmasq is bound to $wireless_id:$AP_IP so it won't conflict."
  fi

  LOGGER step "Restarting dnsmasq"
  if ! sudo systemctl restart dnsmasq; then
    LOGGER error "dnsmasq failed to restart. Last logs:"
    sudo journalctl -u dnsmasq -n 50 --no-pager || true
    exit 1
  fi
  LOGGER step "Populating allow_all ipset"
  while IFS= read -r ip; do
    sudo ipset add allow_all "$ip" || true
  done < "$ALLOW_ALL_IPS_FILE"

  LOGGER step "Setting iptables rules"
  sudo iptables -C FORWARD -m set --match-set allow_all src -j ACCEPT 2>/dev/null || \
    sudo iptables -A FORWARD -m set --match-set allow_all src -j ACCEPT

  sudo iptables -C FORWARD -m set --match-set whitelist dst -j ACCEPT 2>/dev/null || \
    sudo iptables -A FORWARD -m set --match-set whitelist dst -j ACCEPT

  sudo iptables -C FORWARD -j REJECT 2>/dev/null || \
    sudo iptables -A FORWARD -j REJECT

  LOGGER step "Saving ipsets"
  sudo ipset save | sudo tee /etc/ipset.conf > /dev/null

  LOGGER step "Installing ipset-restore systemd service"
  sudo cp "$PROJECT_ROOT/config/ipset-restore.service" "$IPSET_RESTORE_SERVICE"
  sudo systemctl daemon-reload
  sudo systemctl enable ipset-restore.service

  LOGGER step "Restoring ipsets immediately"

  sudo systemctl start ipset-restore.service || echo "Note: sets already exist, skipping start."

  LOGGER ok "Allowlist filtering set up successfully"
}